# <!-- this_file: .workflow-diagram.md -->
# Vexy Stax JS - Workflow Diagrams

Visual documentation of data flow through the application from user input to final output.

**Last Updated**: 2025-11-05
**Version**: v0.2.0
**Iteration**: 67

---

## ðŸ“Š Complete Application Flow

### End-to-End User Journey

```mermaid
graph TB
    Start([User Opens App]) --> Init[Initialize Application]
    Init --> LoadSettings{Load Saved Settings?}

    LoadSettings -->|Yes| RestoreState[Restore Previous State]
    LoadSettings -->|No| DefaultState[Use Default Settings]

    RestoreState --> Ready[App Ready]
    DefaultState --> Ready

    Ready --> UserAction{User Action}

    UserAction -->|Upload Images| FileFlow[File Upload Flow]
    UserAction -->|Adjust Controls| ParamFlow[Parameter Change Flow]
    UserAction -->|Camera Control| CameraFlow[Camera Animation Flow]
    UserAction -->|Export| ExportFlow[Export Flow]

    FileFlow --> Render[Render Scene]
    ParamFlow --> Render
    CameraFlow --> Render

    Render --> Display[Update Canvas]
    Display --> UserAction

    ExportFlow --> Output[PNG/JSON Download]
    Output --> UserAction

    UserAction -->|Close/Refresh| SaveSettings[Save Settings to localStorage]
    SaveSettings --> End([Session End])

    style Start fill:#90EE90
    style End fill:#FFB6C1
    style Render fill:#FFD700
    style Output fill:#87CEEB
```

---

## ðŸ“ File Upload Workflow

### Image Loading and Validation

```mermaid
sequenceDiagram
    participant User
    participant FileInput as File Input
    participant Validation as validateImageFile()
    participant Memory as Memory Check
    participant Loader as TextureLoader
    participant Scene as SceneManager
    participant State as AppState
    participant Canvas

    User->>FileInput: Drop/Select image file
    FileInput->>Validation: Validate file

    alt Invalid MIME type
        Validation-->>User: Show error toast
    else Valid MIME type
        Validation->>Memory: Check memory usage

        alt Memory > 1000MB
            Memory-->>User: Critical warning + confirm
            User->>Memory: User declines
            Memory-->>User: Abort upload
        else Memory OK or user confirms
            Memory->>Loader: Create FileReader
            Loader->>Loader: Read as Data URL

            alt Load fails (retry 1)
                Loader->>Loader: Wait 100ms, retry
            end

            alt Load fails (retry 2)
                Loader->>Loader: Wait 200ms, retry
            end

            alt Load fails (retry 3)
                Loader->>Loader: Wait 400ms, retry
            end

            alt All retries fail
                Loader-->>User: Show error toast
            else Success
                Loader->>Scene: Create texture
                Scene->>Scene: Create mesh with material
                Scene->>State: Add to imageStack[]
                State->>Scene: Position mesh (z = index * zSpacing)
                Scene->>Canvas: Render updated scene
                Canvas-->>User: Display new image
            end
        end
    end
```

**Key Points**:
- MIME type validation: `image/png`, `image/jpeg`, `image/gif`, `image/webp`, `image/svg+xml`
- File size: 50MB hard limit, 10MB warning
- Memory monitoring: 500MB warning, 1000MB critical (with user confirmation)
- Retry logic: 3 attempts with exponential backoff (100ms, 200ms, 400ms)
- Z-positioning: `mesh.position.z = index * zSpacing` (default 50px)

---

## ðŸŽ›ï¸ Parameter Change Workflow

### UI Control to Scene Update

```mermaid
sequenceDiagram
    participant User
    participant Tweakpane as Tweakpane Control
    participant Handler as onChange Handler
    participant AppState as AppState
    participant EventBus as EventBus
    participant Manager as Scene/Lighting/Floor Manager
    participant Three as Three.js Scene
    participant Canvas

    User->>Tweakpane: Adjust slider/picker
    Tweakpane->>Handler: Trigger onChange(value)
    Handler->>AppState: set(key, value)
    AppState->>AppState: Store in state Map
    AppState->>EventBus: emit('state:changed', {key, value})

    alt Material property
        EventBus->>Manager: Update all meshes
        Manager->>Three: mesh.material[property] = value
    else Camera property
        EventBus->>Manager: Update camera
        Manager->>Three: camera[property] = value
    else Lighting property
        EventBus->>Manager: Update lights
        Manager->>Three: light[property] = value
    else Floor property
        EventBus->>Manager: Update floor
        Manager->>Three: floor.material[property] = value
    end

    Manager->>Canvas: Trigger render
    Canvas->>Canvas: RenderLoop calls render()
    Canvas-->>User: Updated visual
```

**Key Parameters**:
- **zSpacing** (0-500px): Distance between layers
- **materialPreset**: 10 presets (flat-matte, glossy-photo, plastic-card, thick-board, metal-sheet, glass-slide, 3d-box, metallic-card, satin, soft-glow)
- **roughness** (0-1): Material surface roughness
- **metalness** (0-1): Metallic appearance
- **thickness** (1-50): Mesh depth for 3D box material
- **cameraMode**: perspective, orthographic, isometric, telephoto
- **viewpoint**: front, top, beauty, side, 3d-stack, center, isometric

---

## ðŸ“· Camera Animation Workflow

### Viewpoint Preset Transitions

```mermaid
sequenceDiagram
    participant User
    participant UI as Tweakpane Button
    participant Handler as Preset Handler
    participant AppState as AppState
    participant Animator as CameraAnimator
    participant GSAP as GSAP Library
    participant Camera as THREE.Camera
    participant Controls as OrbitControls
    participant Canvas

    User->>UI: Click viewpoint preset (e.g., "Beauty")
    UI->>Handler: Trigger preset handler
    Handler->>AppState: get('currentViewpoint')

    alt Same viewpoint
        Handler-->>User: Skip animation
    else Different viewpoint
        Handler->>Animator: animateToPosition(preset)
        Animator->>GSAP: gsap.to(camera.position, {...})
        Animator->>GSAP: gsap.to(controls.target, {...})

        loop Animation frames (1.5 seconds)
            GSAP->>Camera: Update camera.position
            GSAP->>Controls: Update controls.target
            Camera->>Canvas: Request render
            Canvas->>Canvas: RenderLoop renders frame
            Canvas-->>User: Smooth transition
        end

        GSAP->>Animator: Animation complete
        Animator->>AppState: set('currentViewpoint', preset)
        Animator->>Controls: controls.update()
        Animator->>Canvas: Final render
        Canvas-->>User: New viewpoint
    end
```

**Preset Positions**:
- **front**: (0, 0, 800) - Straight-on view
- **top**: (0, 800, 0) - Bird's eye view
- **beauty**: (-300, 200, 500) - Classic 3/4 angle
- **side**: (-800, 0, 0) - Profile view
- **3d-stack**: (-400, 300, 400) - Isometric-style
- **center**: (0, 0, 600) - Centered perspective
- **isometric**: (-577, 577, 577) - True isometric (45Â°)

**Animation Details**:
- Duration: 1.5 seconds
- Easing: GSAP `power2.inOut`
- Both camera position and target animated simultaneously
- OrbitControls disabled during animation, re-enabled after

---

## ðŸ’¾ Export Workflows

### PNG Export (High-Resolution Render)

```mermaid
flowchart TD
    Start([User clicks Export PNG]) --> Scale{Select Scale}

    Scale -->|1x| Render1[Render at current size]
    Scale -->|2x| Render2[Render at 2x size]
    Scale -->|4x| Render4[Render at 4x size]

    Render1 --> Resize1[Resize canvas: width, height]
    Render2 --> Resize2[Resize canvas: width*2, height*2]
    Render4 --> Resize4[Resize canvas: width*4, height*4]

    Resize1 --> SetSize1[renderer.setSize]
    Resize2 --> SetSize2[renderer.setSize]
    Resize4 --> SetSize4[renderer.setSize]

    SetSize1 --> RenderScene[renderer.render scene, camera]
    SetSize2 --> RenderScene
    SetSize4 --> RenderScene

    RenderScene --> ToBlob[canvas.toBlob type: image/png]

    ToBlob --> CreateLink[Create download link]
    CreateLink --> Filename[vexy-stax-YYYY-MM-DD-HH-mm-ss.png]
    Filename --> Download[Trigger browser download]

    Download --> Restore[Restore original canvas size]
    Restore --> End([PNG Downloaded])

    style Start fill:#90EE90
    style End fill:#87CEEB
    style RenderScene fill:#FFD700
```

**PNG Export Details**:
- Scales: 1x (current), 2x (retina), 4x (print quality)
- Format: PNG with full alpha channel
- Background: Transparent if bgAlpha < 1.0
- Antialiasing: Enabled in renderer
- Filename: `vexy-stax-${timestamp}.png`
- Temporary upscaling: Canvas resized, rendered, then restored

---

### JSON Export (Full Scene Save)

```mermaid
flowchart TD
    Start([User clicks Export JSON]) --> GetState[Get AppState snapshot]

    GetState --> SerializeParams[Serialize all parameters]
    SerializeParams --> GetImages[Get imageStack from AppState]

    GetImages --> LoopImages{For each image}

    LoopImages --> GetMesh[Get mesh.userData]
    GetMesh --> GetTexture[Get mesh.material.map]
    GetTexture --> ExtractData[Extract texture.image src]

    ExtractData --> CheckType{Data URL?}

    CheckType -->|Yes| UseDataURL[Use existing dataURL]
    CheckType -->|No| ConvertCanvas[Convert canvas to base64]

    UseDataURL --> BuildObj[Build image object]
    ConvertCanvas --> BuildObj

    BuildObj --> AddToArray[Add to images array]
    AddToArray --> LoopImages

    LoopImages -->|All done| BuildJSON[Build final JSON structure]

    BuildJSON --> AddVersion[Add version: "0.2.0"]
    AddVersion --> AddImages[Add images array]
    AddImages --> AddParams[Add params object]

    AddParams --> Stringify[JSON.stringify with indentation]
    Stringify --> CreateBlob[Create Blob type: application/json]
    CreateBlob --> CreateLink[Create download link]
    CreateLink --> Filename[vexy-stax-YYYY-MM-DD-HH-mm-ss.json]
    Filename --> Download[Trigger browser download]

    Download --> End([JSON Downloaded])

    style Start fill:#90EE90
    style End fill:#87CEEB
    style Stringify fill:#FFD700
```

**JSON Structure**:
```json
{
  "version": "0.2.0",
  "images": [
    {
      "filename": "image-1.png",
      "dataURL": "data:image/png;base64,iVBORw0KG..."
    }
  ],
  "params": {
    "zSpacing": 50,
    "cameraMode": "perspective",
    "materialPreset": "glossy-photo",
    ...
  }
}
```

**Key Points**:
- All parameters saved (camera, material, lighting, floor)
- Images embedded as base64 data URLs
- Version field for compatibility checking
- Pretty-printed with 2-space indentation
- Import validates version and structure

---

## ðŸ“‹ JSON Import Workflow

### Loading Saved Configurations

```mermaid
sequenceDiagram
    participant User
    participant FileInput as File Input
    participant Reader as FileReader
    participant Validator as JSON Validator
    participant Parser as JSON Parser
    participant ImageLoader as Image Loader
    participant AppState as AppState
    participant Scene as SceneManager
    participant UI as Tweakpane
    participant Canvas

    User->>FileInput: Select .json file
    FileInput->>Reader: Read as text
    Reader->>Validator: Validate structure

    alt Invalid JSON
        Validator-->>User: Show error toast
    else Valid JSON
        Validator->>Parser: JSON.parse()
        Parser->>Parser: Check version compatibility

        alt Incompatible version
            Parser-->>User: Show warning + ask confirm
            User->>Parser: User declines
            Parser-->>User: Abort import
        else Compatible or user confirms
            Parser->>Scene: clearAll() - Remove existing images
            Scene->>AppState: Clear imageStack[]

            Parser->>ImageLoader: Load images array

            loop For each image
                ImageLoader->>ImageLoader: Validate dataURL
                ImageLoader->>Scene: Create texture from dataURL
                Scene->>Scene: Create mesh
                Scene->>AppState: Add to imageStack[]
            end

            Parser->>AppState: Restore all params
            AppState->>UI: Update all controls
            AppState->>Scene: Apply material settings
            AppState->>Scene: Apply camera settings
            AppState->>Scene: Apply lighting settings
            AppState->>Scene: Apply floor settings

            Scene->>Canvas: Render updated scene
            Canvas-->>User: Display imported configuration
        end
    end
```

**Validation Checks**:
1. **JSON syntax**: Valid parseable JSON
2. **Version field**: Must have `"version"` string
3. **Images array**: Must be array with `filename` and `dataURL` properties
4. **Params object**: Must have required material/camera parameters
5. **Data URLs**: Must start with `data:image/`

**Import Actions**:
- Clear existing scene completely
- Load all images sequentially (maintain order)
- Restore all parameters to AppState
- Sync UI controls to match imported state
- Trigger full scene rebuild

---

## ðŸ”„ State Management Flow

### Centralized State with Event-Driven Updates

```mermaid
graph TB
    subgraph Producers [State Change Producers]
        UIControls[UI Controls]
        FileUpload[File Upload]
        Keyboard[Keyboard Shortcuts]
        Import[JSON Import]
    end

    subgraph Core [Core State System]
        AppState[AppState Singleton]
        EventBus[EventBus Singleton]
    end

    subgraph Consumers [State Change Consumers]
        SceneManager[SceneManager]
        LightingManager[LightingManager]
        FloorManager[FloorManager]
        CameraAnimator[CameraAnimator]
        UISync[Tweakpane Sync]
    end

    UIControls -->|set key, value| AppState
    FileUpload -->|pushTo imageStack| AppState
    Keyboard -->|set cameraMode| AppState
    Import -->|batch set| AppState

    AppState -->|emit state:changed| EventBus

    EventBus -->|subscribe| SceneManager
    EventBus -->|subscribe| LightingManager
    EventBus -->|subscribe| FloorManager
    EventBus -->|subscribe| CameraAnimator
    EventBus -->|subscribe| UISync

    SceneManager -->|update meshes| Render[Render Loop]
    LightingManager -->|update lights| Render
    FloorManager -->|update floor| Render
    CameraAnimator -->|update camera| Render

    Render -->|requestAnimationFrame| Canvas[WebGL Canvas]
    Canvas -->|display| User

    style AppState fill:#FFD700
    style EventBus fill:#87CEEB
    style Render fill:#90EE90
```

**State Operations**:
- **get(key)**: Retrieve value from state Map
- **set(key, value)**: Store value, emit `state:changed`
- **mergeInto(key, patch)**: Deep merge for nested objects
- **pushTo(key, item)**: Add to array property
- **removeFrom(key, predicate)**: Remove from array
- **reset(key)**: Restore initial value
- **snapshot()**: Get full state copy

**Event Channels**:
- `state:changed` - Any state modification
- `camera:mode` - Camera mode switch
- `image:loaded` - New image added
- `image:removed` - Image deleted
- `material:changed` - Material preset change

---

## âš¡ Render Loop Flow

### Animation Frame Management

```mermaid
sequenceDiagram
    participant RAF as requestAnimationFrame
    participant RenderLoop as RenderLoop
    participant Callback as Render Callback
    participant Controls as OrbitControls
    participant Renderer as THREE.WebGLRenderer
    participant Canvas as HTML Canvas
    participant FPS as FPS Monitor

    Note over RAF,FPS: Continuous 60fps Loop

    loop Every Frame
        RAF->>RenderLoop: Next frame tick
        RenderLoop->>FPS: Update frame counter

        alt FPS enabled
            FPS->>FPS: Calculate average FPS
            alt FPS < 30
                FPS->>Console: Warn low FPS
            end
        end

        RenderLoop->>Callback: Call user render function
        Callback->>Controls: controls.update()
        Callback->>Renderer: renderer.render(scene, camera)
        Renderer->>Canvas: WebGL draw operations
        Canvas->>Canvas: Swap buffers

        RenderLoop->>RAF: Queue next frame
    end
```

**Performance Characteristics**:
- **Target**: 60 FPS (16.67ms per frame)
- **Warning**: <30 FPS triggers console warning
- **FPS calculation**: Rolling average over 1 second window
- **Frame budget**: ~16ms for JavaScript + render
- **Optimization**: OrbitControls.enableDamping = true (smooth movement)

**RenderLoop API**:
- `setRenderCallback(fn)` - Set function called each frame
- `start()` - Begin animation loop
- `stop()` - Cancel animation loop
- `showFPS(enabled)` - Toggle FPS display
- `getFPSStats()` - Get current FPS metrics

---

## ðŸ” Error Recovery Workflows

### WebGL Context Loss Recovery

```mermaid
sequenceDiagram
    participant GPU
    participant Canvas
    participant Event as webglcontextlost Event
    participant Handler as Context Loss Handler
    participant User
    participant Restore as webglcontextrestored Event
    participant RestoreHandler as Context Restore Handler
    participant Renderer as THREE.WebGLRenderer
    participant Scene as Scene Rebuild

    GPU->>Canvas: Context loss (GPU reset/driver crash)
    Canvas->>Event: Fire webglcontextlost
    Event->>Handler: Call handler
    Handler->>Handler: event.preventDefault()
    Handler->>User: Show warning toast "WebGL context lost..."

    Note over GPU,User: User waits for GPU recovery

    GPU->>Canvas: Context restored
    Canvas->>Restore: Fire webglcontextrestored
    Restore->>RestoreHandler: Call handler
    RestoreHandler->>User: Remove warning toast
    RestoreHandler->>Renderer: Restore renderer settings
    RestoreHandler->>Scene: Reload all textures
    Scene->>Scene: Recreate all meshes
    Scene->>Canvas: Render updated scene
    Canvas->>User: Display recovered scene
```

**Recovery Actions**:
1. **Context loss detected**: Display user warning
2. **Prevent default**: Keep canvas alive for restoration
3. **Context restored**: Remove warning, rebuild scene
4. **Texture reload**: Re-upload all images to GPU
5. **Settings restore**: shadowMap, clearColor, canvas dimensions

---

## ðŸ§ª Testing Workflow

### Unit Test Execution Flow

```mermaid
flowchart TD
    Start([npm run test:unit]) --> NodeTest[Node.js Test Runner]
    NodeTest --> LoadTests[Load 15 test suites]

    LoadTests --> Suite1[api_input_validation.test.js - 10 tests]
    LoadTests --> Suite2[core_app_state.test.js - 24 tests]
    LoadTests --> Suite3[core_constants.test.js - 40 tests]
    LoadTests --> Suite4[core_event_bus.test.js - 24 tests]
    LoadTests --> Suite5[core_render_loop.test.js - 20 tests]
    LoadTests --> Suite6[error_recovery.test.js - 23 tests]
    LoadTests --> Suite7[integration_cross_module.test.js - 5 tests]
    LoadTests --> Suite8[ordering.test.js - 8 tests]
    LoadTests --> Suite9[scene_floor_manager.test.js - 7 tests]
    LoadTests --> Suite10[scene_lighting_manager.test.js - 10 tests]
    LoadTests --> Suite11[scene_manager.test.js - 8 tests]
    LoadTests --> Suite12[shared_state.test.js - 15 tests]
    LoadTests --> Suite13[studio_sizing.test.js - 11 tests]
    LoadTests --> Suite14[utils_helpers.test.js - 14 tests]
    LoadTests --> Suite15[utils_logger.test.js - 4 tests]

    Suite1 --> Collect[Collect Results]
    Suite2 --> Collect
    Suite3 --> Collect
    Suite4 --> Collect
    Suite5 --> Collect
    Suite6 --> Collect
    Suite7 --> Collect
    Suite8 --> Collect
    Suite9 --> Collect
    Suite10 --> Collect
    Suite11 --> Collect
    Suite12 --> Collect
    Suite13 --> Collect
    Suite14 --> Collect
    Suite15 --> Collect

    Collect --> Aggregate[Aggregate: 223 tests total]
    Aggregate --> Report[Generate Report]

    Report --> AllPass{All Pass?}

    AllPass -->|Yes| Success[Exit 0 - Success]
    AllPass -->|No| Failure[Exit 1 - Failure]

    Success --> End([Tests Complete])
    Failure --> End

    style Start fill:#90EE90
    style Success fill:#87CEEB
    style Failure fill:#FFB6C1
    style Collect fill:#FFD700
```

**Test Execution Details**:
- **Runtime**: ~650ms for all 223 tests
- **Coverage**: 96% core, 100% utils
- **Test runner**: Node.js built-in test runner (v18+)
- **Watch mode**: Not used (run once per iteration)
- **Parallel**: Tests run in parallel across files
- **Timeout**: Default 30 seconds per test

---

## ðŸŽ¯ Related Documentation

- [.architecture-diagram.md](.architecture-diagram.md) - System architecture with Mermaid diagrams
- [.project-metrics.md](.project-metrics.md) - Project statistics and health metrics
- [.documentation-index.md](.documentation-index.md) - Complete documentation navigation
- [.testing-guide.md](.testing-guide.md) - Testing standards and patterns
- [.cicd-workflow.md](.cicd-workflow.md) - CI/CD pipeline documentation

---

**Workflow Status**: âœ… Complete application data flow documented

*Diagrams generated with Mermaid - view in GitHub or compatible Markdown viewer*
