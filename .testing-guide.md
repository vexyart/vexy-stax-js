# this_file: .testing-guide.md
# Testing Best Practices Guide

## Overview

This guide documents testing standards and best practices for Vexy Stax JS. Use this as a reference when writing new tests or reviewing existing test coverage.

---

## Test Suite Organization

### Current Structure (223 tests across 16 suites)

```
tests/
â”œâ”€â”€ api_input_validation.test.js       # Public API input sanitization (10 tests)
â”œâ”€â”€ core_app_state.test.js            # AppState lifecycle & operations (16 tests)
â”œâ”€â”€ core_constants.test.js            # Constants validation (21 tests)
â”œâ”€â”€ core_event_bus.test.js            # EventBus pub/sub patterns (16 tests)
â”œâ”€â”€ core_integration.test.js          # Cross-module integration (5 tests)
â”œâ”€â”€ core_ordering.test.js             # Array reordering utilities (8 tests)
â”œâ”€â”€ core_render_loop.test.js          # Animation loop & FPS monitoring (20 tests)
â”œâ”€â”€ core_shared_state.test.js         # Shared state registry (12 tests)
â”œâ”€â”€ core_studio_sizing.test.js        # Retina/DPR calculations (9 tests)
â”œâ”€â”€ error_recovery.test.js            # Manager cleanup & dispose (23 tests)
â”œâ”€â”€ managers_camera_animation.test.js # Camera animation (10 tests)
â”œâ”€â”€ managers_floor.test.js            # Floor creation/removal (7 tests)
â”œâ”€â”€ managers_lighting.test.js         # Lighting setup (5 tests)
â”œâ”€â”€ managers_scene.test.js            # Scene initialization (8 tests)
â”œâ”€â”€ utils_helpers.test.js             # Helper functions (28 tests)
â””â”€â”€ utils_logger.test.js              # Logger utilities (4 tests)
```

### Suite Naming Convention

- **Pattern**: `{category}_{module}.test.js`
- **Categories**:
  - `core_` - Core utilities (AppState, EventBus, constants, etc.)
  - `managers_` - Scene/manager modules (SceneManager, FloorManager, etc.)
  - `utils_` - Utility functions (helpers, logger)
  - `api_` - Public API validation
  - Special cases: `error_recovery`, `core_integration`

---

## Writing Tests

### 1. Test Structure

```javascript
// this_file: tests/example.test.js
import { describe, it } from 'node:test';
import assert from 'node:assert/strict';

describe('ModuleName', () => {
  describe('functionName()', () => {
    it('returns expected value for valid input', () => {
      const result = functionName('valid');
      assert.strictEqual(result, 'expected');
    });

    it('throws TypeError for invalid input', () => {
      assert.throws(
        () => functionName(null),
        { name: 'TypeError', message: /expected/ }
      );
    });
  });
});
```

### 2. Test Naming

**Format**: `{action} {condition} {expected_result}`

**Examples**:
- âœ… `returns default value when key does not exist`
- âœ… `throws TypeError when callback is not a function`
- âœ… `updates FPS display when enabled`
- âŒ `test function` (too vague)
- âŒ `it works` (not descriptive)

### 3. Assertion Patterns

```javascript
// Equality
assert.strictEqual(actual, expected, 'values should be equal');
assert.deepStrictEqual(obj1, obj2, 'objects should match');

// Truthiness
assert.ok(condition, 'condition should be truthy');
assert.equal(value, true, 'should be true');

// Errors
assert.throws(() => fn(), { name: 'TypeError' });
assert.throws(() => fn(), { message: /expected pattern/ });

// Type checking
assert.strictEqual(typeof value, 'number');
assert.ok(Array.isArray(value));
assert.ok(value instanceof Class);

// Regex matching
assert.match(string, /pattern/, 'should match pattern');
```

---

## Test Coverage Standards

### Coverage Thresholds (Enforced via c8)

```json
{
  "lines": 80,      // 80% line coverage minimum
  "functions": 80,  // 80% function coverage minimum
  "branches": 75    // 75% branch coverage minimum
}
```

### Current Coverage Status

| Module | Coverage | Notes |
|--------|----------|-------|
| **Core Utilities** | 96.41% | AppState, EventBus, RenderLoop, constants |
| **Utils** | 100% | helpers.js, logger.js |
| **Scene Managers** | 58.33% | Requires E2E tests (WebGL context) |
| **Camera** | 53.53% | Requires E2E tests (GSAP animations) |
| **main.js** | 0% | Requires E2E tests (DOM + Three.js) |
| **Overall** | 38.61% | Low due to untested main.js (3,367 lines) |

### What to Test

1. **Happy Path** âœ…
   - Valid inputs produce expected outputs
   - Core functionality works as intended

2. **Edge Cases** âœ…
   - Empty arrays/strings/objects
   - null/undefined inputs
   - Boundary values (0, -1, MAX_VALUE)
   - Extreme values (very large numbers, very long strings)

3. **Error Conditions** âœ…
   - Invalid types throw TypeError
   - Out-of-bounds values throw RangeError
   - Missing required parameters throw Error
   - Error messages include context (function name, actual value)

4. **State Management** âœ…
   - Objects are properly cloned (no mutation)
   - Event listeners are cleaned up
   - Resources are disposed correctly

5. **Integration** âœ…
   - Modules work together correctly
   - Shared state synchronization
   - Event propagation across modules

---

## Performance Testing

### Baseline Metrics (Iteration 60)

**Total Duration**: 627.0ms Â±3.2ms (223 tests)

**Thresholds**:
- âš ï¸ Warning: >700ms (+11% from baseline)
- ðŸš¨ Critical: >800ms (+27% from baseline)

### Performance Testing Guidelines

1. **Avoid setTimeout/setInterval** unless testing debounce/throttle
2. **Use async/await** for dynamic imports, not Promises
3. **Keep test suites isolated** - no shared module-level state
4. **Minimize file I/O** - use in-memory fixtures where possible

### Monitoring Commands

```bash
# Run tests with timing
npm run test:unit

# Run 5 iterations for consistency check
for i in {1..5}; do npm run test:unit 2>&1 | grep "duration_ms"; done

# Check for performance regression
npm run test:unit 2>&1 | grep "duration_ms" | awk '{if ($2 > 700) print "WARNING: Slow tests", $2 "ms"}'
```

---

## Common Testing Patterns

### Pattern 1: Dynamic Import for Module Isolation

```javascript
it('resets all state to initial values', async () => {
  const { AppState } = await import('../src/core/AppState.js');
  const state = new AppState({ count: 0 });

  state.set('count', 5);
  state.reset();

  assert.strictEqual(state.get('count'), 0);
});
```

**Why**: Ensures each test gets fresh module instance, prevents test pollution.

### Pattern 2: Testing Immutability

```javascript
it('does not allow mutation of frozen nested objects', () => {
  assert.throws(
    () => { MAIN_LIGHT_SETTINGS.position.x = 999; },
    { name: 'TypeError' },
    'Should prevent mutation of nested position object'
  );
});
```

**Why**: Validates constants are properly frozen at all nesting levels.

### Pattern 3: Error Message Validation

```javascript
it('includes function name in error message', () => {
  assert.throws(
    () => calculateLuminance('invalid'),
    { message: /calculateLuminance:/ },
    'Error should include function name for context'
  );
});
```

**Why**: Ensures error messages are helpful for debugging.

### Pattern 4: Testing Cleanup/Disposal

```javascript
it('disposes all managers and cleans up resources', () => {
  const scene = new SceneManager();
  const lighting = new LightingManager(scene);

  scene.dispose();
  lighting.dispose();

  assert.strictEqual(scene.renderer, null, 'Renderer should be cleaned up');
  assert.strictEqual(lighting.lights.length, 0, 'Lights should be removed');
});
```

**Why**: Prevents memory leaks from undisposed Three.js objects.

### Pattern 5: Async Test with Timeout

```javascript
it('debounces function calls correctly', async () => {
  let callCount = 0;
  const debounced = debounce(() => callCount++, 50);

  debounced();
  debounced();
  debounced();

  await new Promise(resolve => setTimeout(resolve, 100)); // Wait 2x debounce delay

  assert.strictEqual(callCount, 1, 'Should only call once after debounce period');
});
```

**Why**: Tests time-dependent behavior with sufficient safety margin.

---

## Test Documentation

### Suite Headers (JSDoc)

Every test file should have a comprehensive header:

```javascript
/**
 * this_file: tests/example.test.js
 *
 * Test Suite: Example Module
 *
 * Purpose:
 * Validates the example module's core functionality including...
 *
 * Scope:
 * - Function validation (input/output correctness)
 * - Error handling (TypeError for invalid inputs)
 * - Edge cases (null, undefined, empty values)
 *
 * Test Count: 12 tests
 * Dependencies: node:test, node:assert/strict
 *
 * Related Modules:
 * - src/core/example.js (implementation)
 * - src/utils/helpers.js (used by example.js)
 */
```

### Test Comments

```javascript
// Valid inputs produce expected outputs
it('returns sum of two numbers', () => {
  assert.strictEqual(add(2, 3), 5);
});

// Edge case: zero handling
it('returns zero when both inputs are zero', () => {
  assert.strictEqual(add(0, 0), 0);
});

// Error case: type validation
it('throws TypeError for non-numeric input', () => {
  assert.throws(() => add('2', 3), { name: 'TypeError' });
});
```

---

## Running Tests

### Basic Commands

```bash
# Run all unit tests
npm run test:unit

# Run all tests (unit + E2E)
npm test

# Generate coverage report
npm run test:coverage

# Enforce coverage thresholds
npm run test:coverage:check
```

### Coverage Reports

```bash
# View HTML coverage report
open coverage/index.html

# View text summary
npm run test:coverage

# View lcov report (for CI)
cat coverage/lcov.info
```

### Debugging Tests

```bash
# Run with --inspect flag
node --inspect --test tests/specific.test.js

# Run specific test file
node --test tests/core_app_state.test.js

# Run with verbose output
node --test --test-reporter=spec
```

---

## What NOT to Test

### âŒ Avoid Testing Implementation Details

```javascript
// BAD: Testing internal variable names
it('sets _internalCache property', () => {
  const obj = new MyClass();
  assert.ok(obj._internalCache); // Testing private implementation
});

// GOOD: Testing public behavior
it('caches results for repeated calls', () => {
  const obj = new MyClass();
  const first = obj.getValue();
  const second = obj.getValue();
  assert.strictEqual(first, second); // Testing observable behavior
});
```

### âŒ Avoid Testing Third-Party Libraries

```javascript
// BAD: Testing Three.js functionality
it('THREE.Vector3 normalizes correctly', () => {
  const vec = new THREE.Vector3(1, 0, 0);
  vec.normalize();
  assert.strictEqual(vec.length(), 1);
});

// GOOD: Testing our usage of Three.js
it('creates camera with correct FOV', () => {
  const camera = createCamera({ fov: 75 });
  assert.strictEqual(camera.fov, 75);
});
```

### âŒ Avoid Flaky Tests

```javascript
// BAD: Timing-dependent without safety margin
it('updates after delay', async () => {
  setTimeout(() => state.update(), 50);
  await new Promise(resolve => setTimeout(resolve, 50)); // Exact timing, flaky!
  assert.ok(state.isUpdated);
});

// GOOD: Sufficient safety margin
it('updates after delay', async () => {
  setTimeout(() => state.update(), 50);
  await new Promise(resolve => setTimeout(resolve, 100)); // 2x delay, reliable!
  assert.ok(state.isUpdated);
});
```

---

## Test Maintenance

### When to Update Tests

1. **Bug Fixes**: Add regression test before fixing bug
2. **New Features**: Write tests before implementation (TDD)
3. **Refactoring**: Ensure all existing tests still pass
4. **Performance Changes**: Update `.test-performance.md` baseline

### Red-Green-Refactor Cycle

1. ï¿½ï¿½ï¿½ **Red**: Write failing test for new feature
2. ðŸŸ¢ **Green**: Write minimal code to pass test
3. ðŸ”µ **Refactor**: Improve code while keeping tests green

### Test Review Checklist

- [ ] Test names are descriptive
- [ ] All edge cases covered
- [ ] Error conditions tested
- [ ] No flaky timing dependencies
- [ ] Proper cleanup/disposal
- [ ] JSDoc header present
- [ ] Coverage thresholds met (80/80/75%)

---

## Troubleshooting

### Tests Pass Locally But Fail in CI

**Possible Causes**:
- Environment differences (Node.js version, OS)
- Timing issues (slower CI machines)
- Missing dependencies

**Solutions**:
- Check `.nvmrc` matches CI Node.js version
- Increase timeout safety margins
- Verify `package-lock.json` is committed

### Coverage Suddenly Drops

**Possible Causes**:
- New untested code added
- Code moved from tested to untested module
- Coverage tool configuration changed

**Solutions**:
- Run `npm run test:coverage` to see uncovered lines
- Add tests for new code
- Check `.c8rc.json` configuration

### Flaky Test Failures

**Possible Causes**:
- Timing dependencies (setTimeout/setInterval)
- Shared module state between tests
- File system race conditions

**Solutions**:
- Use dynamic imports for isolation
- Increase timeout safety margins (2x-3x)
- Mock time-dependent functions

---

## Resources

- **Test Runner**: Node.js built-in test runner (v18+)
- **Assertion Library**: node:assert/strict
- **Coverage Tool**: c8 (v10.1.3)
- **Performance Baseline**: `.test-performance.md`
- **Test Conventions**: `.test-conventions.md`
- **Contributing**: `CONTRIBUTING.md`

---

**Last Updated**: 2025-11-05 (Iteration 62)
**Test Count**: 223 tests across 16 suites
**Coverage**: 96.41% (core), 100% (utils), 38.61% (overall)
